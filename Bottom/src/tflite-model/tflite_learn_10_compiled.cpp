/*
 * Copyright (c) 2024 EdgeImpulse Inc.
 *
 * Generated by Edge Impulse and licensed under the applicable Edge Impulse
 * Terms of Service. Community and Professional Terms of Service
 * (https://docs.edgeimpulse.com/page/terms-of-service) or Enterprise Terms of
 * Service (https://docs.edgeimpulse.com/page/enterprise-terms-of-service),
 * according to your product plan subscription (the “License”).
 *
 * This software, documentation and other associated files (collectively referred
 * to as the “Software”) is a single SDK variation generated by the Edge Impulse
 * platform and requires an active paid Edge Impulse subscription to use this
 * Software for any purpose.
 *
 * You may NOT use this Software unless you have an active Edge Impulse subscription
 * that meets the eligibility requirements for the applicable License, subject to
 * your full and continued compliance with the terms and conditions of the License,
 * including without limitation any usage restrictions under the applicable License.
 *
 * If you do not have an active Edge Impulse product plan subscription, or if use
 * of this Software exceeds the usage limitations of your Edge Impulse product plan
 * subscription, you are not permitted to use this Software and must immediately
 * delete and erase all copies of this Software within your control or possession.
 * Edge Impulse reserves all rights and remedies available to enforce its rights.
 *
 * Unless required by applicable law or agreed to in writing, the Software is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing
 * permissions, disclaimers and limitations under the License.
 */
// Generated on: 17.12.2024 09:10:06

#include <stdio.h>
#include <stdlib.h>
#include "edge-impulse-sdk/tensorflow/lite/c/builtin_op_data.h"
#include "edge-impulse-sdk/tensorflow/lite/c/common.h"
#include "edge-impulse-sdk/tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "edge-impulse-sdk/porting/ei_classifier_porting.h"

#if EI_CLASSIFIER_PRINT_STATE
#if defined(__cplusplus) && EI_C_LINKAGE == 1
extern "C" {
    extern void ei_printf(const char *format, ...);
}
#else
extern void ei_printf(const char *format, ...);
#endif
#endif

#define STRINGIZE(x) #x
#define STRINGIZE_VALUE_OF(x) STRINGIZE(x)

#if defined (__GNUC__)  /* GNU compiler */
#define ALIGN(X) __attribute__((aligned(X)))
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (_MSC_VER)
#define ALIGN(X) __declspec(align(X))
#elif defined (__TASKING__) /* TASKING Compiler */
#define ALIGN(X) __align(X)
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (__ARMCC_VERSION) /* Arm Compiler */
#define ALIGN(X) __ALIGNED(x)
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (__ICCARM__) /* IAR Compiler */
#define ALIGN(x) __attribute__((aligned(x)))
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (__clang__) /* LLVM/Clang Compiler */
#define ALIGN(X) __ALIGNED(x)
#define DEFINE_SECTION(x) __attribute__((section(x)))
#endif

#if defined(EI_MODEL_SECTION) && (defined(__GNUC__) || defined(__clang__))
#define MODEL_SECTION(X) __attribute__((section(STRINGIZE_VALUE_OF(X))))
#else
#define MODEL_SECTION(X)
#endif

#ifndef EI_MAX_SCRATCH_BUFFER_COUNT
#ifndef CONFIG_IDF_TARGET_ESP32S3
#define EI_MAX_SCRATCH_BUFFER_COUNT 4
#else
#define EI_MAX_SCRATCH_BUFFER_COUNT 8
#endif // CONFIG_IDF_TARGET_ESP32S3
#endif // EI_MAX_SCRATCH_BUFFER_COUNT

#ifndef EI_MAX_OVERFLOW_BUFFER_COUNT
#define EI_MAX_OVERFLOW_BUFFER_COUNT 10
#endif // EI_MAX_OVERFLOW_BUFFER_COUNT

using namespace tflite;
using namespace tflite::ops;
using namespace tflite::ops::micro;

namespace {

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX) || defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
constexpr int kTensorArenaSize = 18128;
#else
constexpr int kTensorArenaSize = 17104;
#endif

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC)
#if defined (EI_TENSOR_ARENA_LOCATION)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) DEFINE_SECTION(STRINGIZE_VALUE_OF(EI_TENSOR_ARENA_LOCATION));
#else
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#endif
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX)
#pragma Bss(".tensor_arena")
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#pragma Bss()
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) __attribute__((section(".tensor_arena")));
#else
#define EI_CLASSIFIER_ALLOCATION_HEAP 1
uint8_t* tensor_arena = NULL;
#endif

static uint8_t* tensor_boundary;
static uint8_t* current_location;

template <int SZ, class T> struct TfArray {
  int sz; T elem[SZ];
};

enum used_operators_e {
  OP_RESHAPE, OP_CONV_2D, OP_MAX_POOL_2D, OP_FULLY_CONNECTED, OP_SOFTMAX,  OP_LAST
};

struct TensorInfo_t { // subset of TfLiteTensor used for initialization from constant memory
  TfLiteAllocationType allocation_type;
  TfLiteType type;
  void* data;
  TfLiteIntArray* dims;
  size_t bytes;
  TfLiteQuantization quantization;
};

typedef struct {
  TfLiteTensor tensor;
  int16_t index;
} TfLiteTensorWithIndex;

typedef struct {
  TfLiteEvalTensor tensor;
  int16_t index;
} TfLiteEvalTensorWithIndex;

TfLiteContext ctx{};
static const int MAX_TFL_TENSOR_COUNT = 4;
static TfLiteTensorWithIndex tflTensors[MAX_TFL_TENSOR_COUNT];
static const int MAX_TFL_EVAL_COUNT = 4;
static TfLiteEvalTensorWithIndex tflEvalTensors[MAX_TFL_EVAL_COUNT];
TfLiteRegistration registrations[OP_LAST];

namespace g0 {
const TfArray<2, int> tensor_dimension0 = { 2, { 1,7960 } };
const TfArray<1, float> quant0_scale = { 1, { 0.0025888481177389622, } };
const TfArray<1, int> quant0_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant0 = { (TfLiteFloatArray*)&quant0_scale, (TfLiteIntArray*)&quant0_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data1[4] = { 1, 1, 199, 40, };
const TfArray<1, int> tensor_dimension1 = { 1, { 4 } };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data2[4] = { 1, 199, 1, 8, };
const TfArray<1, int> tensor_dimension2 = { 1, { 4 } };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data3[4] = { 1, 1, 100, 8, };
const TfArray<1, int> tensor_dimension3 = { 1, { 4 } };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data4[4] = { 1, 100, 1, 16, };
const TfArray<1, int> tensor_dimension4 = { 1, { 4 } };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(8) int32_t tensor_data5[2] = { -1, 800, };
const TfArray<1, int> tensor_dimension5 = { 1, { 2 } };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(8) int32_t tensor_data6[2] = { 1527, -1527, };
const TfArray<1, int> tensor_dimension6 = { 1, { 2 } };
const TfArray<1, float> quant6_scale = { 1, { 2.7218344257562421e-05, } };
const TfArray<1, int> quant6_zero = { 1, { 0 } };
const TfLiteAffineQuantization quant6 = { (TfLiteFloatArray*)&quant6_scale, (TfLiteIntArray*)&quant6_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int8_t tensor_data7[2*800] = { 
  7, -25, -15, 13, 15, -12, 8, -7, 8, 21, -28, -14, -23, -3, -8, -12, 30, 22, -4, 9, 28, 2, -9, 19, -4, 2, 24, 20, 18, 50, -4, 5, 24, 48, 82, -13, -6, -25, 4, 29, 21, 35, -31, 16, -37, 20, 16, 37, 41, -6, 45, -40, 33, -9, 9, -5, -24, -11, 10, -31, -13, 14, -16, 100, 37, 10, 85, 1, -61, 51, -50, -2, -12, -12, -3, -44, 1, 29, 14, 76, 42, 38, 51, 5, -49, 47, -56, 31, 1, -25, -3, -8, 44, 34, -14, 58, 43, 48, 113, -7, 3, 45, -67, 18, 1, 8, -37, -11, -6, -25, 35, 50, 14, 35, 9, 34, -10, 38, -39, -6, -11, -35, -26, -25, 33, -5, 48, 21, 2, 12, -32, 11, -13, 7, -7, 2, -32, -7, -10, 0, 18, -12, -12, 10, -17, -28, -8, 7, -43, 15, -40, -17, -33, -24, -10, -42, -9, 37, -18, -3, -33, -16, -13, -19, -66, -23, -7, 16, -17, -41, -29, -1, 35, 18, -17, -37, -18, -20, 5, 0, -24, 1, -12, -3, -16, -50, -33, -38, -19, -2, -43, -13, -5, -9, 11, -26, -44, -25, -18, -7, -23, -23, 9, -29, 7, -8, -36, 54, -38, -9, -8, -12, -44, -26, -2, -9, -21, -22, -1, -44, 9, -17, -3, 27, -3, 15, 30, -4, -40, -13, -21, -21, -3, -12, 13, -46, -13, 15, -28, 44, 27, 25, 4, -39, -38, 6, -39, -16, -19, -18, -12, -39, 5, -3, 9, 1, 7, 25, 39, -28, -91, 12, -75, -19, -25, -7, -21, 31, -5, -22, 16, 29, 36, -19, 11, -64, -22, -20, -26, -17, -37, -54, -35, -45, -1, 8, -11, 70, 42, 25, 10, -79, -34, -7, -16, -4, -38, -27, 22, -31, -29, 26, -26, 68, 21, 15, 63, -66, -45, 18, -51, -39, -45, -49, -42, -72, -1, -14, -13, 86, 13, -33, 40, -75, -11, 4, -5, -15, -53, -19, -17, -32, -17, 42, -21, 99, 7, -7, 59, -61, 9, 30, -8, -38, -33, -13, -31, -101, 13, 59, 3, 55, 50, 35, 38, -65, -50, -8, -43, -33, -18, -22, 4, -78, -33, 31, 17, 62, 24, -10, 54, -65, -19, 35, -35, -36, -4, 17, 20, -75, -3, 27, 0, 36, 30, -13, 39, -47, -58, 6, -31, -5, -50, -25, -23, -62, -34, 40, 14, 126, -6, 14, 53, -58, -76, 0, -32, -21, -38, -32, 27, -15, -9, -4, 2, 55, 5, 15, 19, -57, -48, -2, 7, -34, -7, -26, 0, -54, -10, -20, -18, 39, -16, -22, 21, -26, -33, -17, -32, -48, -31, -15, -12, -27, -25, -1, -44, 35, 20, -9, 39, -69, -70, 21, -56, 3, -47, -1, 15, -21, -30, -13, -55, 59, 22, -5, 39, -82, -15, 49, -28, -46, -41, -7, 20, -95, -53, -10, 5, 112, 40, 1, 39, -12, -32, 48, -15, -16, 1, -25, -7, -44, 3, -21, 31, 35, 8, -17, 37, 7, -6, 21, -12, -6, -18, 12, -20, -47, 4, -56, -31, 35, 19, 27, 21, -1, 18, -21, -7, -13, 4, 16, 15, -15, -32, -17, 7, 13, 1, 23, 26, -59, 64, 10, 25, 10, 16, 3, 30, -33, -8, -8, -8, 24, 30, -9, 26, -29, 69, -2, -7, 21, -16, 27, 3, -25, 27, 21, 24, -1, 33, 1, 52, -12, 7, 14, 14, -11, 0, 0, -17, -52, 37, -8, -3, 27, 41, -11, 77, -14, 35, 13, -22, 18, -13, -4, -28, -75, -4, 18, 38, 41, 18, 2, 5, 28, 28, 13, 22, 3, 20, -2, -13, -45, 0, -60, 52, 26, 7, 8, 26, 56, 41, 2, 58, -12, 24, 36, 28, 30, 32, -41, 53, -16, 40, 10, 23, 15, 34, 2, 37, 16, -13, 52, -7, 26, -21, -39, 50, 20, 39, 6, 12, -17, 17, 26, 2, 6, -5, 27, 48, -39, 11, -69, 34, 11, 24, 19, 21, -5, 64, -9, 44, -17, -16, 5, 14, -37, -24, -2, 8, 17, 32, -8, 93, -3, 37, 25, 35, 40, -1, 7, -18, -50, -3, 35, 15, 35, 40, 23, 81, 39, -42, 36, -7, 9, 54, 24, 22, 10, 59, 47, 53, 88, 93, 38, 92, 34, -22, 47, -4, 41, 47, 3, 29, -8, 58, -11, 46, 74, 54, 40, -7, 5, 5, 13, 21, 70, 32, 20, 35, 44, 12, -52, 52, 26, 36, 23, 17, 12, -17, 7, 46, 35, 23, 46, 10, 2, -2, -5, 72, -28, 59, 53, 59, -32, 10, 21, 24, 61, 36, 36, 24, 8, -1, 21, 49, 32, 56, 41, 110, 8, 6, 21, 23, 47, 51, 17, -2, 10, 47, -8, 85, 33, 90, 30, 86, -12, -41, 49, 57, 15, 37, 43, -3, -9, 3, 12, 56, 24, 
  23, 7, 25, 6, -9, -5, -43, -4, -26, 6, -16, -19, -2, 47, 10, 19, -13, -30, 20, -51, 6, 3, 13, 3, 9, -26, -5, -31, -8, -17, -6, 43, -14, -19, -64, -19, -9, -25, 21, 13, -32, 8, 4, -19, 23, 8, -40, -45, -18, -11, -34, -1, -23, 5, 28, -20, 10, -33, 28, 52, 3, -32, -18, -109, -30, -3, -84, 4, 51, -43, 23, -2, 22, 16, -21, 14, -24, -33, -10, -85, -57, -47, -63, -2, 46, -67, 77, -33, -10, 29, 16, 19, -50, -51, -25, -52, -17, -21, -77, 5, 28, -39, 70, -2, -17, 17, 7, 30, -20, 13, -39, -70, -19, -9, -19, -7, 44, -44, 39, -44, -8, -7, 28, 40, -7, -24, -9, -50, -15, 0, 10, 6, 16, 16, 32, -20, 4, 13, 7, 22, 13, 16, -14, 2, -6, 3, -5, 22, 56, 24, 6, 39, 40, -7, 30, 31, 13, -29, -7, -24, 11, 10, 5, 31, 46, 2, 28, 25, 4, 45, -3, 17, -33, -25, 40, 26, 51, 15, 29, 15, 37, 1, 5, -7, 1, 4, 22, 15, 11, 12, 3, -35, 4, 6, 8, -7, 71, 14, 27, -3, 12, 11, 5, -4, -3, -33, 18, -54, 17, 20, 27, 50, 16, 43, -20, 2, -3, 35, -10, 53, 21, 47, 10, -27, 9, 10, -19, -35, 26, -24, 51, 8, 16, 8, -12, -2, 10, -4, 6, -32, 0, -28, 21, 9, 75, 6, 50, 12, 21, 44, 11, 20, -25, 21, -25, -32, -3, -7, -9, 19, 53, 25, 50, 28, 23, 14, -15, -6, 37, 40, -6, -66, -25, 26, 3, 78, 27, 21, 21, 27, 33, 43, -4, 65, 15, -4, 14, -33, -28, 24, -31, 58, 61, -8, 57, 35, 38, 24, 24, 76, 12, 9, 21, -48, -26, -2, -47, 42, 50, 6, 58, 17, 61, 5, 14, 34, 54, -4, 35, -119, -3, -19, -25, 47, 29, 9, 19, 9, 40, 28, 10, 48, 42, -41, 29, -86, -51, 4, -43, 63, 25, -23, 21, 12, 28, 42, 9, 67, 35, -18, -23, -57, -22, 7, -16, 68, 29, 2, 31, 22, 13, 40, 31, 70, 5, -12, 6, -75, -24, 10, -28, 61, -4, -17, 38, 41, 41, 23, 27, 95, -22, -52, -3, -50, -10, -11, -42, 39, 92, -10, -13, 4, 46, 28, 4, 93, 18, -34, 15, -127, -3, 14, -56, 49, 29, 10, 41, 6, 18, 10, 0, 15, 14, -17, 7, -94, -11, -12, -48, 9, 44, -40, 11, 17, -2, 19, 10, 58, -9, -12, 21, -46, 1, 15, -12, 56, -3, -13, -11, 11, -5, 2, 18, 45, 32, -24, 0, -33, -20, -34, -39, 76, 64, -18, 40, 29, 29, 2, -7, 14, 22, -9, 48, -67, -27, 0, -13, 79, 12, -3, 23, 28, 3, 11, -34, 93, 34, -18, 3, -77, -12, -28, 6, 8, 38, -39, 42, 28, -14, 23, 26, 54, 5, 6, 15, -54, -45, -11, -35, 8, -27, -19, 4, 36, -2, 22, -6, 49, 16, 32, -10, -20, -30, -5, -21, 42, -3, -11, -17, 5, 17, -7, -21, 24, 15, 42, -19, 10, -23, -25, -5, 64, -61, -13, 20, -10, 24, -12, 13, 20, -15, -18, -5, -50, -10, -10, -11, 19, -43, 4, 18, -28, -12, -1, 10, 56, 2, -22, -14, 21, -34, -34, -38, 15, 14, 5, -10, -30, 18, 24, -27, 54, -2, 17, -10, -3, -63, -18, -54, 5, -36, -15, -3, -41, -28, -6, 3, 34, -7, -29, -27, -56, -32, -23, 11, -15, -58, 3, 9, -16, -31, -24, 9, 39, -34, 59, -23, -44, -31, -9, -30, -58, -23, -3, -16, -25, -58, -48, -8, -37, 3, 49, -16, 39, -37, -12, -24, -36, -33, 7, -72, 7, 18, -21, 18, -25, 2, 42, -56, 21, -22, -29, -25, -5, -38, 3, 5, -49, -8, -13, -8, 22, 0, 49, 1, -3, -34, -38, -21, 41, -43, 9, -52, -18, -13, -16, -4, 39, 14, -34, -35, -33, -56, -12, -74, -8, -2, -9, -31, -50, -9, -24, -10, 27, -38, -6, -19, -19, -61, -63, -85, -33, 51, -46, 42, -13, -23, -17, -41, 2, -38, -46, -38, -66, -77, -58, -77, -50, 32, -56, 32, -42, -45, -20, -24, 3, -38, 38, -9, -31, -42, 6, -3, -8, 7, -15, -60, -68, -46, -37, -23, -42, -42, 14, -58, -23, -15, -29, -28, 18, 18, -23, -33, -13, -54, -49, -37, -38, -7, -22, -22, -6, -51, -25, -68, 30, -26, -51, -16, -31, -47, -14, -11, 4, -18, 17, -57, -32, -81, -32, -59, -15, 22, -42, -31, -22, -16, -41, -10, -5, -74, -28, -58, -21, -57, -58, -67, -7, 56, -65, -32, -20, -29, -6, -40, 1, -37, 20, -26, -59, 
};
const TfArray<2, int> tensor_dimension7 = { 2, { 2,800 } };
const TfArray<1, float> quant7_scale = { 1, { 0.003163826884701848, } };
const TfArray<1, int> quant7_zero = { 1, { 0 } };
const TfLiteAffineQuantization quant7 = { (TfLiteFloatArray*)&quant7_scale, (TfLiteIntArray*)&quant7_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data8[16] = { 1016, 77, 487, -600, 1774, 470, 763, -718, 367, 1570, 1064, -259, -965, 3179, 486, 3346, };
const TfArray<1, int> tensor_dimension8 = { 1, { 16 } };
const TfArray<16, float> quant8_scale = { 16, { 2.363718522246927e-05, 1.9107355910819024e-05, 2.1226582248345949e-05, 2.7326068448019214e-05, 2.2476146114058793e-05, 2.2291911591310054e-05, 2.2341455405694433e-05, 2.4081266019493341e-05, 2.9287462893989868e-05, 1.6642308764858171e-05, 1.4002721400174778e-05, 3.4741875424515456e-05, 2.0228477296768688e-05, 1.7414135072613135e-05, 2.2623278709943406e-05, 2.2047575839678757e-05, } };
const TfArray<16, int> quant8_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant8 = { (TfLiteFloatArray*)&quant8_scale, (TfLiteIntArray*)&quant8_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int8_t tensor_data9[16*1*3*8] = { 
  /* [0][0][][] */ 33,69,127,50,-34,-32,49,55, -3,49,40,-16,-55,-11,96,-45, 41,78,67,23,-69,-54,91,35, 
  /* [1][0][][] */ -30,110,55,68,-9,-90,12,60, -62,13,2,-10,82,71,92,127, 92,42,73,-96,-66,-81,31,13, 
  /* [2][0][][] */ 1,79,-6,14,-35,-52,47,83, 99,55,108,53,-15,-92,42,127, -62,91,77,-42,-79,-17,107,34, 
  /* [3][0][][] */ 86,-45,43,-31,123,2,-48,23, 42,-46,4,52,76,-7,-23,11, -15,-3,-12,-27,127,12,48,13, 
  /* [4][0][][] */ 13,-77,-105,-39,-123,-19,-15,44, 14,-54,-98,-48,-15,108,2,-35, 94,32,54,-17,-54,127,-8,-6, 
  /* [5][0][][] */ -78,91,101,54,-39,-101,-15,101, -72,83,1,-39,36,37,-40,0, -51,127,92,31,-17,-16,-17,74, 
  /* [6][0][][] */ 125,-54,28,68,-72,33,11,2, 98,-106,26,-43,19,33,8,32, 3,-127,-80,75,14,58,-82,-76, 
  /* [7][0][][] */ 19,58,22,-85,-26,82,95,31, 74,67,90,68,116,58,79,36, 61,5,-15,-22,127,30,104,16, 
  /* [8][0][][] */ 55,-68,97,61,64,6,63,33, -4,-54,-27,59,127,1,-53,55, 12,-43,76,47,83,58,-7,-15, 
  /* [9][0][][] */ 106,-86,117,110,31,118,127,63, 44,-64,59,-50,91,95,28,40, 15,-87,25,116,33,86,-9,108, 
  /* [10][0][][] */ -51,-87,-31,66,92,-66,110,-27, -95,-127,-22,-24,-49,-126,-93,42, -65,-42,-13,68,-103,49,-8,126, 
  /* [11][0][][] */ -23,3,-17,61,105,48,-7,-39, 37,-39,13,11,127,-30,7,-2, 34,-29,-36,27,27,-18,-36,-36, 
  /* [12][0][][] */ -85,55,-44,87,57,-28,104,-29, 61,2,-58,-53,-19,34,-54,-24, 96,62,92,19,127,-101,-5,41, 
  /* [13][0][][] */ 27,2,-14,-58,-72,45,5,-58, 71,97,-52,-12,-110,-96,-8,-86, -54,69,121,-13,79,-127,-19,75, 
  /* [14][0][][] */ 51,30,115,-21,-5,39,61,-46, 5,102,127,24,6,-6,89,-36, 81,-56,54,86,21,-81,30,-59, 
  /* [15][0][][] */ 53,127,31,-1,-36,-47,-6,124, 2,47,78,1,-43,-76,50,85, -44,-10,86,-34,-98,-25,59,93, 
};
const TfArray<4, int> tensor_dimension9 = { 4, { 16,1,3,8 } };
const TfArray<16, float> quant9_scale = { 16, { 0.0034741256386041641, 0.0028083445504307747, 0.0031198221258819103, 0.0040163071826100349, 0.0033034796360880136, 0.003276401199400425, 0.0032836829777806997, 0.0035393955186009407, 0.0043045873753726482, 0.002446038881316781, 0.002058079931885004, 0.0051062614656984806, 0.002973123686388135, 0.002559479558840394, 0.0033251047134399414, 0.0032404896337538958, } };
const TfArray<16, int> quant9_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant9 = { (TfLiteFloatArray*)&quant9_scale, (TfLiteIntArray*)&quant9_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data10[8] = { -2676, 2693, -597, -17, -4334, -705, -492, -367, };
const TfArray<1, int> tensor_dimension10 = { 1, { 8 } };
const TfArray<8, float> quant10_scale = { 8, { 9.2963846327620558e-06, 9.0506582637317479e-06, 9.0532621470629238e-06, 7.1380131885234732e-06, 9.0982293841079809e-06, 1.0726769687607884e-05, 7.8163529906305484e-06, 6.4384025790786836e-06, } };
const TfArray<8, int> quant10_zero = { 8, { 0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant10 = { (TfLiteFloatArray*)&quant10_scale, (TfLiteIntArray*)&quant10_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int8_t tensor_data11[8*1*3*40] = { 
  /* [0][0][][] */ -47,-16,7,0,-50,-10,65,-12,-13,-3,22,-36,73,-34,-76,-20,-57,-68,-40,-76,-15,-33,-8,11,-13,-48,-23,-78,-19,-79,-72,41,51,30,87,29,42,22,90,122, -6,13,-44,37,-3,-42,79,48,19,-14,60,76,-34,61,12,15,14,-19,-28,24,-85,4,0,-22,-54,-77,16,-24,23,-47,-49,75,21,10,42,56,67,67,25,95, 34,-5,77,-39,65,-32,-13,10,12,41,-27,-27,50,-32,-40,-32,-71,-63,20,-48,1,-59,-30,-2,-21,-77,-67,9,-31,-37,-35,-5,76,40,42,28,31,106,109,127, 
  /* [1][0][][] */ -81,-97,-103,46,-103,63,-23,91,37,37,14,-33,8,-84,33,28,-33,-15,63,47,15,-47,3,18,38,-24,-50,-25,-12,50,41,-67,-30,32,8,59,-17,-40,-25,-100, 32,-37,-127,13,-52,70,76,84,44,8,21,-7,-10,-90,-66,55,31,-36,-27,-28,17,48,-46,-7,-34,-2,2,-34,4,84,12,-10,-7,69,10,25,2,-6,-26,-106, 56,-86,-84,-38,-112,50,71,34,-28,54,-24,43,16,-78,-28,21,10,50,51,-26,-38,0,-77,29,50,63,-40,52,-11,-11,56,-32,21,-44,-23,74,52,-7,-73,-35, 
  /* [2][0][][] */ 20,11,-127,-26,-77,-47,59,88,4,67,48,-40,9,-86,-60,27,22,-52,41,21,51,-12,-18,6,26,-50,-53,-69,-8,-47,-45,-21,-77,33,44,-27,53,-39,-16,-58, 54,-14,-68,-37,-12,14,50,7,100,0,85,-40,-58,-25,41,16,-66,-50,37,43,3,40,-38,-3,-25,55,-30,-14,-43,-33,-24,3,-80,12,-27,-17,-42,23,-75,-71, 94,-72,-113,-8,16,1,84,111,82,10,-30,-11,-10,-8,-17,21,-62,-62,59,-63,21,16,-61,15,56,-60,-4,-48,7,55,23,-57,-35,-53,19,-28,7,53,-50,-85, 
  /* [3][0][][] */ -96,-42,60,-72,118,-37,84,17,68,-100,-23,-63,-2,25,2,-45,19,-16,8,5,26,26,26,42,0,36,43,-89,39,0,1,13,21,3,13,9,-50,-26,-88,38, -79,-46,80,-36,98,36,95,-21,84,36,-57,-16,-3,-36,51,-77,26,28,-13,33,34,-1,-29,54,-18,-71,40,-68,-5,-56,27,43,1,-32,-59,-54,-26,-71,54,-37, 42,-22,127,-62,94,58,43,27,-64,9,67,-45,-39,36,-75,-14,-26,-26,-46,62,-74,3,-74,2,-59,-18,54,2,48,-85,38,-72,-31,-31,-65,-28,-7,-89,-82,-36, 
  /* [4][0][][] */ 17,-54,47,52,-5,19,48,98,18,-30,-59,38,98,100,-13,4,-100,-107,-95,-84,-81,-98,-78,-41,-80,-17,3,35,33,-64,-95,-49,-101,-74,-18,-93,-76,-19,-77,-5, 30,1,112,-21,15,18,92,25,49,-56,-19,26,68,114,-25,-55,-100,-56,-37,-81,-86,-18,0,12,-44,37,29,-9,-7,-6,-93,9,-95,-87,2,-8,-60,-45,-95,-22, 27,-79,22,-4,22,16,81,71,21,-50,-37,39,121,127,-35,-26,-118,-105,-57,-45,-54,-51,-22,-55,-35,-56,-18,1,-24,-4,-8,-88,2,-20,-89,6,25,-6,-53,-82, 
  /* [5][0][][] */ -21,5,59,29,63,5,-31,-3,-17,9,-27,41,25,46,-19,-12,-69,1,-2,47,-16,-10,40,-63,-21,-55,14,25,-37,39,-61,55,38,19,74,35,28,30,116,66, -52,-55,94,38,53,-12,-37,-43,-39,-48,-50,-36,15,52,-19,-18,-30,-20,47,56,38,-27,21,21,-53,4,-30,40,15,6,-35,8,2,55,10,14,45,97,59,45, 11,-49,114,9,56,11,-5,-19,14,33,26,26,18,58,-25,7,16,-31,11,-28,39,45,-24,13,-29,-37,51,44,14,-23,1,59,26,-19,5,-18,21,13,89,127, 
  /* [6][0][][] */ 32,30,-68,9,-44,-24,7,-5,-11,-24,-7,24,-51,-36,-4,-31,-26,52,35,15,-26,24,-15,40,-16,-13,62,-11,10,-28,-2,-83,12,-41,-45,25,-72,27,-56,-61, -47,-95,-23,0,-73,75,71,86,69,73,8,64,-84,17,47,-39,-35,-57,79,75,-34,-82,-35,-9,-53,56,-10,14,-36,-29,42,15,-81,46,-51,36,45,13,-85,-64, -32,-76,-120,-5,-92,-60,23,18,127,114,-30,-32,-7,-65,-40,-51,63,-53,45,0,-14,-93,18,-2,28,-16,-72,-21,-27,33,-46,-50,-41,46,-16,57,-40,-77,-88,-9, 
  /* [7][0][][] */ 8,-82,-33,25,44,30,-31,106,20,5,97,-92,5,-122,-72,11,-8,64,-42,-8,-21,28,-88,-19,75,-26,-21,49,71,71,-42,-77,26,64,-26,-67,14,-48,-3,-85, -56,-38,-109,-35,-97,-65,89,114,50,83,98,-85,-4,-63,-114,-51,-68,-49,-1,-65,-15,18,29,36,24,-24,-48,39,44,-32,-87,-40,43,31,48,10,2,11,-49,-33, -34,-107,-127,-27,-91,-30,30,72,15,82,6,-1,-119,-10,-9,52,15,43,40,-7,-15,49,32,63,-37,82,15,57,-15,47,26,38,-69,-19,-68,15,-89,-74,8,-17, 
};
const TfArray<4, int> tensor_dimension11 = { 4, { 8,1,3,40 } };
const TfArray<8, float> quant11_scale = { 8, { 0.0035909349098801613, 0.0034960173070430756, 0.0034970233682543039, 0.0027572158724069595, 0.0035143927671015263, 0.004143452737480402, 0.003019239753484726, 0.0024869758635759354, } };
const TfArray<8, int> quant11_zero = { 8, { 0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant11 = { (TfLiteFloatArray*)&quant11_scale, (TfLiteIntArray*)&quant11_zero, 0 };
const TfArray<4, int> tensor_dimension12 = { 4, { 1,1,199,40 } };
const TfArray<1, float> quant12_scale = { 1, { 0.0025888481177389622, } };
const TfArray<1, int> quant12_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant12 = { (TfLiteFloatArray*)&quant12_scale, (TfLiteIntArray*)&quant12_zero, 0 };
const TfArray<4, int> tensor_dimension13 = { 4, { 1,1,199,8 } };
const TfArray<1, float> quant13_scale = { 1, { 0.0068037793971598148, } };
const TfArray<1, int> quant13_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant13 = { (TfLiteFloatArray*)&quant13_scale, (TfLiteIntArray*)&quant13_zero, 0 };
const TfArray<4, int> tensor_dimension14 = { 4, { 1,199,1,8 } };
const TfArray<1, float> quant14_scale = { 1, { 0.0068037793971598148, } };
const TfArray<1, int> quant14_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant14 = { (TfLiteFloatArray*)&quant14_scale, (TfLiteIntArray*)&quant14_zero, 0 };
const TfArray<4, int> tensor_dimension15 = { 4, { 1,100,1,8 } };
const TfArray<1, float> quant15_scale = { 1, { 0.0068037793971598148, } };
const TfArray<1, int> quant15_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant15 = { (TfLiteFloatArray*)&quant15_scale, (TfLiteIntArray*)&quant15_zero, 0 };
const TfArray<4, int> tensor_dimension16 = { 4, { 1,1,100,8 } };
const TfArray<1, float> quant16_scale = { 1, { 0.0068037793971598148, } };
const TfArray<1, int> quant16_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant16 = { (TfLiteFloatArray*)&quant16_scale, (TfLiteIntArray*)&quant16_zero, 0 };
const TfArray<4, int> tensor_dimension17 = { 4, { 1,1,100,16 } };
const TfArray<1, float> quant17_scale = { 1, { 0.0086029814556241035, } };
const TfArray<1, int> quant17_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant17 = { (TfLiteFloatArray*)&quant17_scale, (TfLiteIntArray*)&quant17_zero, 0 };
const TfArray<4, int> tensor_dimension18 = { 4, { 1,100,1,16 } };
const TfArray<1, float> quant18_scale = { 1, { 0.0086029814556241035, } };
const TfArray<1, int> quant18_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant18 = { (TfLiteFloatArray*)&quant18_scale, (TfLiteIntArray*)&quant18_zero, 0 };
const TfArray<4, int> tensor_dimension19 = { 4, { 1,50,1,16 } };
const TfArray<1, float> quant19_scale = { 1, { 0.0086029814556241035, } };
const TfArray<1, int> quant19_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant19 = { (TfLiteFloatArray*)&quant19_scale, (TfLiteIntArray*)&quant19_zero, 0 };
const TfArray<2, int> tensor_dimension20 = { 2, { 1,800 } };
const TfArray<1, float> quant20_scale = { 1, { 0.0086029814556241035, } };
const TfArray<1, int> quant20_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant20 = { (TfLiteFloatArray*)&quant20_scale, (TfLiteIntArray*)&quant20_zero, 0 };
const TfArray<2, int> tensor_dimension21 = { 2, { 1,2 } };
const TfArray<1, float> quant21_scale = { 1, { 0.079487152397632599, } };
const TfArray<1, int> quant21_zero = { 1, { 1 } };
const TfLiteAffineQuantization quant21 = { (TfLiteFloatArray*)&quant21_scale, (TfLiteIntArray*)&quant21_zero, 0 };
const TfArray<2, int> tensor_dimension22 = { 2, { 1,2 } };
const TfArray<1, float> quant22_scale = { 1, { 0.00390625, } };
const TfArray<1, int> quant22_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant22 = { (TfLiteFloatArray*)&quant22_scale, (TfLiteIntArray*)&quant22_zero, 0 };
const TfLiteReshapeParams opdata0 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs0 = { 2, { 0,1 } };
const TfArray<1, int> outputs0 = { 1, { 12 } };
const TfLiteConvParams opdata1 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs1 = { 3, { 12,11,10 } };
const TfArray<1, int> outputs1 = { 1, { 13 } };
const TfLiteReshapeParams opdata2 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs2 = { 2, { 13,2 } };
const TfArray<1, int> outputs2 = { 1, { 14 } };
const TfLitePoolParams opdata3 = { kTfLitePaddingSame, 1,2, 1,2, kTfLiteActNone, { { 0,0, 0, 0 } } };
const TfArray<1, int> inputs3 = { 1, { 14 } };
const TfArray<1, int> outputs3 = { 1, { 15 } };
const TfLiteReshapeParams opdata4 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs4 = { 2, { 15,3 } };
const TfArray<1, int> outputs4 = { 1, { 16 } };
const TfLiteConvParams opdata5 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs5 = { 3, { 16,9,8 } };
const TfArray<1, int> outputs5 = { 1, { 17 } };
const TfLiteReshapeParams opdata6 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs6 = { 2, { 17,4 } };
const TfArray<1, int> outputs6 = { 1, { 18 } };
const TfLitePoolParams opdata7 = { kTfLitePaddingSame, 1,2, 1,2, kTfLiteActNone, { { 0,0, 0, 0 } } };
const TfArray<1, int> inputs7 = { 1, { 18 } };
const TfArray<1, int> outputs7 = { 1, { 19 } };
const TfLiteReshapeParams opdata8 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs8 = { 2, { 19,5 } };
const TfArray<1, int> outputs8 = { 1, { 20 } };
const TfLiteFullyConnectedParams opdata9 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs9 = { 3, { 20,7,6 } };
const TfArray<1, int> outputs9 = { 1, { 21 } };
const TfLiteSoftmaxParams opdata10 = { 1 };
const TfArray<1, int> inputs10 = { 1, { 21 } };
const TfArray<1, int> outputs10 = { 1, { 22 } };
};

TensorInfo_t tensorData[] = {
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 7968), (TfLiteIntArray*)&g0::tensor_dimension0, 7960, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant0))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data1, (TfLiteIntArray*)&g0::tensor_dimension1, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data2, (TfLiteIntArray*)&g0::tensor_dimension2, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data3, (TfLiteIntArray*)&g0::tensor_dimension3, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data4, (TfLiteIntArray*)&g0::tensor_dimension4, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data5, (TfLiteIntArray*)&g0::tensor_dimension5, 8, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data6, (TfLiteIntArray*)&g0::tensor_dimension6, 8, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant6))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data7, (TfLiteIntArray*)&g0::tensor_dimension7, 1600, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant7))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data8, (TfLiteIntArray*)&g0::tensor_dimension8, 64, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant8))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data9, (TfLiteIntArray*)&g0::tensor_dimension9, 384, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant9))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data10, (TfLiteIntArray*)&g0::tensor_dimension10, 32, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant10))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data11, (TfLiteIntArray*)&g0::tensor_dimension11, 960, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant11))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension12, 7960, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant12))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 7968), (TfLiteIntArray*)&g0::tensor_dimension13, 1592, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant13))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension14, 1592, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant14))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 1600), (TfLiteIntArray*)&g0::tensor_dimension15, 800, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant15))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension16, 800, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant16))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 1600), (TfLiteIntArray*)&g0::tensor_dimension17, 1600, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant17))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension18, 1600, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant18))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 1600), (TfLiteIntArray*)&g0::tensor_dimension19, 800, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant19))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension20, 800, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant20))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 800), (TfLiteIntArray*)&g0::tensor_dimension21, 2, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant21))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension22, 2, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant22))}, },
};

#ifndef TF_LITE_STATIC_MEMORY
TfLiteNode tflNodes[11] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs4, (TfLiteIntArray*)&g0::outputs4, (TfLiteIntArray*)&g0::inputs4, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata4)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs5, (TfLiteIntArray*)&g0::outputs5, (TfLiteIntArray*)&g0::inputs5, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata5)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs6, (TfLiteIntArray*)&g0::outputs6, (TfLiteIntArray*)&g0::inputs6, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata6)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs7, (TfLiteIntArray*)&g0::outputs7, (TfLiteIntArray*)&g0::inputs7, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata7)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs8, (TfLiteIntArray*)&g0::outputs8, (TfLiteIntArray*)&g0::inputs8, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata8)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs9, (TfLiteIntArray*)&g0::outputs9, (TfLiteIntArray*)&g0::inputs9, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata9)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs10, (TfLiteIntArray*)&g0::outputs10, (TfLiteIntArray*)&g0::inputs10, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata10)), nullptr, 0, },
};
#else
TfLiteNode tflNodes[11] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs4, (TfLiteIntArray*)&g0::outputs4, (TfLiteIntArray*)&g0::inputs4, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata4)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs5, (TfLiteIntArray*)&g0::outputs5, (TfLiteIntArray*)&g0::inputs5, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata5)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs6, (TfLiteIntArray*)&g0::outputs6, (TfLiteIntArray*)&g0::inputs6, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata6)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs7, (TfLiteIntArray*)&g0::outputs7, (TfLiteIntArray*)&g0::inputs7, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata7)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs8, (TfLiteIntArray*)&g0::outputs8, (TfLiteIntArray*)&g0::inputs8, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata8)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs9, (TfLiteIntArray*)&g0::outputs9, (TfLiteIntArray*)&g0::inputs9, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata9)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs10, (TfLiteIntArray*)&g0::outputs10, (TfLiteIntArray*)&g0::inputs10, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata10)), nullptr, 0, },
};
#endif

used_operators_e used_ops[] =
{OP_RESHAPE, OP_CONV_2D, OP_RESHAPE, OP_MAX_POOL_2D, OP_RESHAPE, OP_CONV_2D, OP_RESHAPE, OP_MAX_POOL_2D, OP_RESHAPE, OP_FULLY_CONNECTED, OP_SOFTMAX, };


// Indices into tflTensors and tflNodes for subgraphs
const size_t tflTensors_subgraph_index[] = {0, 23, };
const size_t tflNodes_subgraph_index[] = {0, 11, };

// Input/output tensors
static const int in_tensor_indices[] = {
  0, 
};

static const int out_tensor_indices[] = {
  22, 
};


size_t current_subgraph_index = 0;

static void init_tflite_tensor(size_t i, TfLiteTensor *tensor) {
  tensor->type = tensorData[i].type;
  tensor->is_variable = false;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  tensor->allocation_type = tensorData[i].allocation_type;
#else
  tensor->allocation_type = (tensor_arena <= tensorData[i].data && tensorData[i].data < tensor_arena + kTensorArenaSize) ? kTfLiteArenaRw : kTfLiteMmapRo;
#endif
  tensor->bytes = tensorData[i].bytes;
  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  if(tensor->allocation_type == kTfLiteArenaRw){
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
      tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
  tensor->quantization = tensorData[i].quantization;
  if (tensor->quantization.type == kTfLiteAffineQuantization) {
    TfLiteAffineQuantization const* quant = ((TfLiteAffineQuantization const*)(tensorData[i].quantization.params));
    tensor->params.scale = quant->scale->data[0];
    tensor->params.zero_point = quant->zero_point->data[0];
  }

}

static void init_tflite_eval_tensor(int i, TfLiteEvalTensor *tensor) {

  tensor->type = tensorData[i].type;

  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  auto allocation_type = tensorData[i].allocation_type;
  if(allocation_type == kTfLiteArenaRw) {
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
    tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
}

static void* overflow_buffers[EI_MAX_OVERFLOW_BUFFER_COUNT];
static size_t overflow_buffers_ix = 0;
static void * AllocatePersistentBufferImpl(struct TfLiteContext* ctx,
                                       size_t bytes) {
  void *ptr;
  uint32_t align_bytes = (bytes % 16) ? 16 - (bytes % 16) : 0;

  if (current_location - (bytes + align_bytes) < tensor_boundary) {
    if (overflow_buffers_ix > EI_MAX_OVERFLOW_BUFFER_COUNT - 1) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d, does not fit in tensor arena and reached EI_MAX_OVERFLOW_BUFFER_COUNT\n",
        (int)bytes);
      return NULL;
    }

    // OK, this will look super weird, but.... we have CMSIS-NN buffers which
    // we cannot calculate beforehand easily.
    ptr = ei_calloc(bytes, 1);
    if (ptr == NULL) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d\n", (int)bytes);
      return NULL;
    }
    overflow_buffers[overflow_buffers_ix++] = ptr;
    return ptr;
  }

  current_location -= bytes;

  // align to the left aligned boundary of 16 bytes
  current_location -= 15; // for alignment
  current_location += 16 - ((uintptr_t)(current_location) & 15);

  ptr = current_location;
  memset(ptr, 0, bytes);

  return ptr;
}

typedef struct {
  size_t bytes;
  void *ptr;
} scratch_buffer_t;

static scratch_buffer_t scratch_buffers[EI_MAX_SCRATCH_BUFFER_COUNT];
static size_t scratch_buffers_ix = 0;

static TfLiteStatus RequestScratchBufferInArenaImpl(struct TfLiteContext* ctx, size_t bytes,
                                                int* buffer_idx) {
  if (scratch_buffers_ix > EI_MAX_SCRATCH_BUFFER_COUNT - 1) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d, reached EI_MAX_SCRATCH_BUFFER_COUNT\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffer_t b;
  b.bytes = bytes;

  b.ptr = AllocatePersistentBufferImpl(ctx, b.bytes);
  if (!b.ptr) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffers[scratch_buffers_ix] = b;
  *buffer_idx = scratch_buffers_ix;

  scratch_buffers_ix++;

  return kTfLiteOk;
}

static void* GetScratchBufferImpl(struct TfLiteContext* ctx, int buffer_idx) {
  if (buffer_idx > (int)scratch_buffers_ix) {
    return NULL;
  }
  return scratch_buffers[buffer_idx].ptr;
}

static const uint16_t TENSOR_IX_UNUSED = 0x7FFF;

static void ResetTensors() {
  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    tflTensors[ix].index = TENSOR_IX_UNUSED;
  }
  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    tflEvalTensors[ix].index = TENSOR_IX_UNUSED;
  }
}

static TfLiteTensor* GetTensorImpl(const struct TfLiteContext* context,
                               int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    // already used? OK!
    if (tflTensors[ix].index == tensor_idx) {
      return &tflTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_tensor(tensor_idx, &tflTensors[ix].tensor);
      tflTensors[ix].index = tensor_idx;
      return &tflTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_TENSOR_COUNT (%d)\n", MAX_TFL_TENSOR_COUNT);
  return nullptr;
}

static TfLiteEvalTensor* GetEvalTensorImpl(const struct TfLiteContext* context,
                                       int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    // already used? OK!
    if (tflEvalTensors[ix].index == tensor_idx) {
      return &tflEvalTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflEvalTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_eval_tensor(tensor_idx, &tflEvalTensors[ix].tensor);
      tflEvalTensors[ix].index = tensor_idx;
      return &tflEvalTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_EVAL_COUNT (%d)\n", (int)MAX_TFL_EVAL_COUNT);
  return nullptr;
}

class EonMicroContext : public MicroContext {
 public:
 
  EonMicroContext(): MicroContext(nullptr, nullptr, nullptr) { }

  void* AllocatePersistentBuffer(size_t bytes) {
    return AllocatePersistentBufferImpl(nullptr, bytes);
  }

  TfLiteStatus RequestScratchBufferInArena(size_t bytes,
                                           int* buffer_index) {
  return RequestScratchBufferInArenaImpl(nullptr, bytes, buffer_index);
  }

  void* GetScratchBuffer(int buffer_index) {
    return GetScratchBufferImpl(nullptr, buffer_index);
  }
 
  TfLiteTensor* AllocateTempTfLiteTensor(int tensor_index) {
    return GetTensorImpl(nullptr, tensor_index);
  }

  void DeallocateTempTfLiteTensor(TfLiteTensor* tensor) {
    return;
  }

  bool IsAllTempTfLiteTensorDeallocated() {
    return true;
  }

  TfLiteEvalTensor* GetEvalTensor(int tensor_index) {
    return GetEvalTensorImpl(nullptr, tensor_index);
  }

};


} // namespace

TfLiteStatus tflite_learn_10_init( void*(*alloc_fnc)(size_t,size_t) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  tensor_arena = (uint8_t*) alloc_fnc(16, kTensorArenaSize);
  if (!tensor_arena) {
    ei_printf("ERR: failed to allocate tensor arena\n");
    return kTfLiteError;
  }
#else
  memset(tensor_arena, 0, kTensorArenaSize);
#endif
  tensor_boundary = tensor_arena;
  current_location = tensor_arena + kTensorArenaSize;

  EonMicroContext micro_context_;
  
  // Set microcontext as the context ptr
  ctx.impl_ = static_cast<void*>(&micro_context_);
  // Setup tflitecontext functions
  ctx.AllocatePersistentBuffer = &AllocatePersistentBufferImpl;
  ctx.RequestScratchBufferInArena = &RequestScratchBufferInArenaImpl;
  ctx.GetScratchBuffer = &GetScratchBufferImpl;
  ctx.GetTensor = &GetTensorImpl;
  ctx.GetEvalTensor = &GetEvalTensorImpl;
  ctx.ReportError = &MicroContextReportOpError;

  ctx.tensors_size = 23;
  for (size_t i = 0; i < 23; ++i) {
    TfLiteTensor tensor;
    init_tflite_tensor(i, &tensor);
    if (tensor.allocation_type == kTfLiteArenaRw) {
      auto data_end_ptr = (uint8_t*)tensor.data.data + tensorData[i].bytes;
      if (data_end_ptr > tensor_boundary) {
        tensor_boundary = data_end_ptr;
      }
    }
  }

  if (tensor_boundary > current_location /* end of arena size */) {
    ei_printf("ERR: tensor arena is too small, does not fit model - even without scratch buffers\n");
    return kTfLiteError;
  }

  registrations[OP_RESHAPE] = Register_RESHAPE();
  registrations[OP_CONV_2D] = Register_CONV_2D();
  registrations[OP_MAX_POOL_2D] = Register_MAX_POOL_2D();
  registrations[OP_FULLY_CONNECTED] = Register_FULLY_CONNECTED();
  registrations[OP_SOFTMAX] = Register_SOFTMAX();

  for (size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].init) {
        tflNodes[i].user_data = registrations[used_ops[i]].init(&ctx, (const char*)tflNodes[i].builtin_data, 0);
      }
    }
  }
  current_subgraph_index = 0;

  for(size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].prepare) {
        ResetTensors();
        TfLiteStatus status = registrations[used_ops[i]].prepare(&ctx, &tflNodes[i]);
        if (status != kTfLiteOk) {
          return status;
        }
      }
    }
  }
  current_subgraph_index = 0;

  return kTfLiteOk;
}

TfLiteStatus tflite_learn_10_input(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(in_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_10_output(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(out_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_10_invoke() {
  for (size_t i = 0; i < 11; ++i) {
    ResetTensors();

    TfLiteStatus status = registrations[used_ops[i]].invoke(&ctx, &tflNodes[i]);

#if EI_CLASSIFIER_PRINT_STATE
    ei_printf("layer %lu\n", i);
    ei_printf("    inputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].inputs->size; ix++) {
      auto d = tensorData[tflNodes[i].inputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");

    ei_printf("    outputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].outputs->size; ix++) {
      auto d = tensorData[tflNodes[i].outputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");
#endif // EI_CLASSIFIER_PRINT_STATE

    if (status != kTfLiteOk) {
      return status;
    }
  }
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_10_reset( void (*free_fnc)(void* ptr) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  free_fnc(tensor_arena);
#endif

  // scratch buffers are allocated within the arena, so just reset the counter so memory can be reused
  scratch_buffers_ix = 0;

  // overflow buffers are on the heap, so free them first
  for (size_t ix = 0; ix < overflow_buffers_ix; ix++) {
    ei_free(overflow_buffers[ix]);
  }
  overflow_buffers_ix = 0;
  return kTfLiteOk;
}
